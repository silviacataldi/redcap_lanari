<?php

namespace Vanderbilt\REDCap\Classes\Fhir\TokenManager;

use User;
use Logging;
use Exception;
use HttpClient;
use UserRights;
use SplObserver;
use Vanderbilt\REDCap\Classes\Fhir\FhirClient;
use Vanderbilt\REDCap\Classes\Parcel\PostMaster;
use Vanderbilt\REDCap\Classes\Fhir\FhirClientResponse;
use Vanderbilt\REDCap\Classes\Fhir\Utility\ProjectProxy;
use Vanderbilt\REDCap\Classes\Fhir\Endpoints\FhirRequest;
use Vanderbilt\REDCap\Classes\Fhir\FhirSystem\FhirSystem;

class FhirTokenManager implements SplObserver
{
    /**
     * FHIR system being used
     *
     * @var FhirSystem
     */
    private $fhirSystem;
    /**
     * user ID to use when storing and retrieving tokens from the database
     *
     * @var int
     */
    private $user_id;

    /**
     * project ID used to retrieve a group of users
     *
     * @var int
     */
    private $project_id;

    /**
     * project ID used to retrieve a group of users
     *
     * @var string
     */
    private $patient_id;
    
    /**
     * ordered list of preferred UI_IDs to use when retrieving tokens
     *
     * @var array
     */
    private $preferredUsers = [];

    /**
     *
     * @param FhirSystem $fhirSystem
     * @param int $user_id
     * @param int $project_id
     * @param string $patient_id
     */
    function __construct($fhirSystem, $user_id=null, $project_id=null, $patient_id=null)
    {
        $this->fhirSystem = $fhirSystem;
        $this->user_id = $user_id;
        $this->project_id = $project_id;
        $this->patient_id = $patient_id;
        $users = $this->getUsers();
        $this->setPreferredUsers($users);
    }

    public function getFhirSystem() { return $this->fhirSystem; }

    /**
     * get a users priority list.
     * - if a user_id is provided, then the list will include just the user.
     * - if a project is provided, then the list will include users from the project
     * - return an empty list otherwise
     *
     * @return array
     */
    public function getUsers() {
        $users = [];
        if($this->user_id) {
            $users[] = $this->user_id;
            return $users;
        }
        if($this->project_id) {
            $projectUsers = $this->getProjectUsers($this->project_id);
            $users = array_merge($users, $projectUsers);
        }
        return array_unique($users);
    }

    /**
     * return a list of users eligible for feedback
     * users are selected based on the user rights of a project and
     * ordered based on the FHIR interaction they had
     *
     * @return array
     */
    public function getFeedbackUsers() {
        if(!$this->project_id) return [];
        $logsSubquery = sprintf(
            "SELECT `user_id`, MAX(`created_at`) AS `created_at`
            FROM `redcap_ehr_fhir_logs`
            WHERE `project_id`=%u AND `user_id` IS NOT NULL
            GROUP BY `user_id`", $this->project_id
        );
        $queryString = sprintf(
            "SELECT `ui`.`ui_id`,`ui`.`username`, `logs`.`created_at` FROM `redcap_user_information` AS ui
            LEFT JOIN `redcap_user_rights` AS `ur` ON `ui`.`username`=`ur`.`username`
            LEFT JOIN (%s) AS logs ON `logs`.`user_id`=`ui`.`ui_id`
            WHERE `project_id`=%u
            ORDER BY `logs`.`created_at` DESC",
            $logsSubquery,
            $this->project_id
        );
        $result = db_query($queryString);
        if(!$result) return [];
        $users = [];
        while($row=db_fetch_assoc($result)) {
            $ui_id = $row['ui_id'] ?? '';
            $username = $row['username'] ?? '';
            $users[$ui_id] = $username;
        }
        return $users;
    }

    /**
     * title used as title for feedback messages
     */
    const FEEDBACK_MESSAGE_TITLE = '[EHR Automated Data Pull Alert]';
    const FEEDBACK_MESSAGE_DELAY = 60*30;

    /**
     * send an alert
     *
     * @param string $message
     * @return int|null thread_id or null if the message is not sent
     */
    public function sendAlert($message) {
        $project_id = $this->project_id;
        if(!$project_id) return;

        $project = new ProjectProxy($project_id);

        $project_creator = $project->project['created_by'] ?? '';
        $userInfo = User::getUserInfoByUiid($project_creator);
        $username = $userInfo['username'];

        $html = '[This message was automatically generated by REDCap]'.PHP_EOL;
        $html .= $message;

        $userNames = $this->getFeedbackUsers();
        if(empty($userNames)) return;
        $title = self::FEEDBACK_MESSAGE_TITLE." - PID {$project_id}";

        $postMaster = new PostMaster();
        $postMaster->sendParcel($to=$username, $from='REDCap - FhirToken Manager', $subject=$title, $body=$html);
        return;
    }

    /**
     * return the list of preferred users to used when retrieving tokens
     *
     * @return array
     */
    public function getPreferredUsers() { return $this->preferredUsers; }

    /**
     *
     * @param array $users
     * @return void
     */
    public function setPreferredUsers($users) { $this->preferredUsers = $users; }

    /**
     *
     * @return int
     */
    public function getUserId() { return $this->user_id; }

    /**
     *
     * @return string
     */
    public function getPatientId() { return $this->patient_id; }

    /**
     *
     * @param string $patient_id
     * @return void
     */
    public function setPatientId($patient_id) { return $this->patient_id = $patient_id; }

    /**
     * get a valid access token for a user
     * refresh the token if expired
     * if the refresh fails, try the next token
     *
     * @return FhirToken|false a valid access token or false if not 
     */
    public function getToken()
    {
        $tokens = $this->getTokens();
        $token = current($tokens);
        if($token===false) return false;

        if($token->isExpired())
        {
            if(empty($token->refresh_token)) return false; // Cannot refresh the token; no refresh token available
            $tokenInfo = $this->refreshToken($token->refresh_token);
            if(!$tokenInfo) return false;
            $access_token = $tokenInfo->access_token ?? null;
            $expires_in = $tokenInfo->expires_in ?? null;
            if(!is_string($access_token) || !is_numeric($expires_in)) return false;
            $token->refresh($tokenInfo->access_token, $tokenInfo->expires_in);
        }

        // check if token is valid
        if($token->isValid()) return $token;
        

        // if the token has not been refreshed try the next token
        return $this->getToken();
    }

    /**
	 * refresh a token
	 *
	 * @param string $refresh_token
	 * @return object
	 */
	public function refreshToken($refresh_token)
	{
		$data = array(
			'grant_type' => 'refresh_token',
			'refresh_token' => $refresh_token,
		);
		$tokenBearer = $this->fhirSystem->getAuthorizationHeader();
		$headers = array(
			'Accept' => 'application/json',
			'Content-type' => 'application/x-www-form-urlencoded',
			'Authorization' => "Basic {$tokenBearer}",
		);
		$http_options = array(
			'form_params' => $data,
			'headers' => $headers,
		);
		try {
			$tokenUrl = $this->fhirSystem->getFhirTokenUrl();
			$result = HttpClient::request('POST', $tokenUrl, $http_options);
			$token_info = json_decode($result->getBody());
			if(!isset($token_info->refresh_token)) $token_info->refresh_token = $refresh_token;
			return $token_info;
		} catch (\Exception $e) {
			// throw $e;
            return false;
		}
	}

    /**
     * get an access token
     * 
     * @throws Exception if access token is not available
     * @return string
     */
    public function getAccessToken()
    {
        $token = $this->getToken();
        if(!$token) return false;
        $access_token = $token->getAccessToken();
        return $access_token;
    }


    /**
     * no token available
     *
     * @throws Exception
     */
    private function throwNoTokensAvailableException()
    {
        throw new \Exception("Error: no tokens available.", 1);
    }

    /**
     * the query is designed to select all valid access tokens
     * related to a particular project.
     * If the project does not have an associated ehr_id, it defaults
     * to the ehr_id with the lowest order from the ehr_settings table.
     * Then it further filters to ensure the tokens are active based on the expiration
     * logic and that they belong to any of the provided token_owners,
     * ordering the final output first by relevance to token_owner 
     * and then by expiration dates in descending order.
     *
     * @param integer $user_id
     * @return FhirToken[]
     */
    public function getTokens()
    {
        if(empty($this->preferredUsers)) return [];

        $implodeWithQuotes = function($array) {
            return "'" . implode("', '", $array) . "'";
        };
        $selectQuery = function() {
            $now = date('Y-m-d H:i:s');
            $ehrID = $this->fhirSystem->getEhrId();
            $query_string = sprintf(
                "SELECT * FROM redcap_ehr_access_tokens WHERE
                ehr_id = %u
                AND (
                    (access_token IS NOT NULL AND expiration > %2\$s)
                    OR
                    (refresh_token IS NOT NULL AND expiration > DATE_SUB(%2\$s, INTERVAL 30 DAY))
                )", $ehrID, checkNull($now)
            );
            return $query_string;
        };
        $whereQuery = function() use($implodeWithQuotes) {
            $query_string = sprintf( " AND token_owner IN (%s)", $implodeWithQuotes($this->preferredUsers) );
            return $query_string;
        };
        $orderByQuery = function() use($implodeWithQuotes) {
            $order_by_clauses = [];
            // prioritize patient specific tokens
            if(isset($this->patient_id)) $order_by_clauses[] = sprintf("FIELD (patient, %s) DESC", checkNull($this->patient_id));
            $order_by_clauses[] = sprintf("FIELD (token_owner, %s) DESC", $implodeWithQuotes($this->preferredUsers));
            $order_by_clauses[] = 'expiration DESC';
            
            $order_by_string = " ORDER BY ".implode(', ', $order_by_clauses);
            return $order_by_string;
        };
        
        $query_string = $selectQuery();
        $query_string .= $whereQuery();
        $query_string .= $orderByQuery();
        
        // query the DB
        $list = [];        
        $result = db_query($query_string);
        while($tokenInfo = db_fetch_object($result))
        {
            $list[] = new FhirToken($tokenInfo);
        }

        return $list;
    }

    /**
     * get an ordered list of users with a valid access token (active or refreshable)
     * for a specific project was
     * the project creator is the first in the list
     *
     * @return array
     */
    public function getProjectUsers()
    {
        $project_id = $this->project_id;
        if(!$project_id) return [];

        $getProjectUsers = function() use($project_id) {
            $projectsPrivileges = UserRights::getPrivileges($project_id);
            $usersInfo = $projectsPrivileges[$project_id] ?? [];
            $usernames = array_keys($usersInfo);
            $user_ids = array_map(function($username) {
                return User::getUIIDByUsername($username);
            }, $usernames);
            return $user_ids;
        };

        $getProjectCreator = function() use($project_id) {
            $db = new \RedCapDB();
            $projectInfo = $db->getProject($project_id);
            $project_creator = $projectInfo->created_by;
            return $project_creator;
        };

        $users = $getProjectUsers();
        
        $projectCreator = $getProjectCreator();
        // prepend the project creator
        if($projectCreator) array_unshift($users, $projectCreator);

        return array_unique($users);
    }

    /**
     * persist a token to the database
     *
     * @param object|array $token_data
     * @param integer $user_id
     * @return FhirToken
     */
    public static function storeToken($token_data, $user_id=null)
    {
        $token = new FhirToken($token_data);
        if($user_id) $token->setOwner($user_id);
        $token->save();
        return $token;
    }

    // If there is an institution-specific MRN, then store in access token table to pair it with the patient id
    /**
     * Undocumented function
     *
     * @param string $patient
     * @param string $mrn
     * @return void
     */
	public function storePatientMrn($patient, $mrn)
	{
	    if (empty($mrn)) return false;
		$query_string = "UPDATE redcap_ehr_access_tokens SET mrn = ?
				        WHERE patient=? AND ehr_id = ?";
        $params = [$mrn, $patient, $this->fhirSystem->getEhrId()];
		return db_query($query_string);
    }
    
    /**
     * cleanup MRN entries for a user
     * 
     * the table could contain orphaned MRNs 
     * if the FHIR ID changes for any reason (i.e. EHR updates)
     *
     * @param integer $user_id token owner
     * @param string $mrn
     * @param string $patient_id
     * @return boolean
     */
    public function removeOrphanedMrns($mrn, $patient_id)
    {
        if(!$user_id = $this->user_id) return;
        $query_string = 
            "DELETE FROM redcap_ehr_access_tokens 
            WHERE mrn=? AND token_owner=?
            AND patient != ?";
        return db_query($query_string, [$mrn, $user_id, $patient_id]);
    }

    /**
     * remove all entries of a FHIR id (patient)
     * used when we get a 400 or 404 error fetching a FHIR resource
     * @param string $patient_id
     * @return bool
     */
    public function removeCachedPatient($patient_id)
    {
        $ehrID = $this->fhirSystem->getEhrId();
        $sqlCallables = [];
        // delete if no access token is associated
        $sqlCallables[] = function() use($patient_id, $ehrID) {
            $this->fhirSystem->getEhrId();
            $sql = "DELETE FROM `redcap_ehr_access_tokens`
                WHERE `patient`= ? AND ehr_id = ?
                AND `access_token` IS NULL";
            return db_query($sql, [$patient_id, $ehrID]);
        };

        // update with null values if there is an access token associated
        $sqlCallables[] = function() use($patient_id, $ehrID) {
            $sql = "UPDATE `redcap_ehr_access_tokens` SET `patient`=NULL, `mrn`=NULL
            WHERE `patient`=? AND ehr_id = ? AND `access_token` IS NOT NULL";
            return db_query($sql, [$patient_id, $ehrID]);
        };
        
            // Begin transaction
        db_query("SET AUTOCOMMIT=0");
        db_query("BEGIN");
        foreach ($sqlCallables as $callable) {
            $result = $callable();
            if($result===false) {
                db_query("ROLLBACK");
			    db_query("SET AUTOCOMMIT=1");
                return false;
            }
        }
        db_query("COMMIT");
		db_query("SET AUTOCOMMIT=1");
        return true;
    }

    /**
	 * react to notifications (from the FHIR client)
	 *
	 * @param SplSubject $subject
	 * @param string $event
	 * @param mixed $data
	 * @return void
	 */
	public function update($subject, string $event = null, $data = null): void
	{
        $updateFhirClient = function() use($subject, $event, $data) {
            switch ($event) {
                case FhirClient::NOTIFICATION_PATIENT_IDENTIFIED:
                    $mrn = $data['mrn'] ?? '';
                    $fhir_id = $data['fhir_id'] ?? '';
                    $this->onPatientIdentified($mrn, $fhir_id);
                    break;
                case FhirClient::NOTIFICATION_RESOURCE_ERROR:
                    if(!($subject instanceof FhirClient)) break;
                    /** @var FhirClientResponse $data  */
                    $this->onFhirClientError($data);
                    break;
                default:
                    break;
            }
        };
        
        if($subject instanceof FhirClient) $updateFhirClient();
	}


    /**
     * cache the FHIR ID when a patient is identified
     *
     * @param string $mrn
     * @param string $fhir_id
     * @return void
     */
    private function onPatientIdentified($mrn, $fhir_id)
    {
        $query_string = 'INSERT INTO `redcap_ehr_access_tokens` (`mrn`, `patient`, `ehr_id`) VALUES (?, ?, ?)';
        $ehr_id = $this->fhirSystem->getEhrId();
        $result = db_query($query_string, [$mrn, $fhir_id, $ehr_id]);
        if($result) Logging::logEvent(
            $sql = $query_string,
            $table = 'redcap_ehr_access_token',
            $event = 'FHIR',
            $record = '',
            $display = json_encode(compact('fhir_id', 'mrn'), JSON_PRETTY_PRINT),
            $descrip = 'Patient FHIR ID has been cached',
            $change_reason = 'Patient identified',
            $userid_override = "",
            $project_id_override = 0,
            $useNOW = true,
            $event_id_override = null,
            $instance = null,
            $bulkProcessing = false
        );
    }

    /**
     * perform actions when errors are detected
     * (e.g. delete access token if access is forbidden)
     * @param FhirClientResponse $fhirClientResponse
     * @return void
     */
    private function onFhirClientError($fhirClientResponse)
    {
        $error = $fhirClientResponse->error;
        if(!$error instanceof Exception) return;
        $code = $error->getCode();
        switch ($code) {
            // delete identifier if 'Wrong format' or 'not found'
            case '400':
            case '404':
                $request = $fhirClientResponse->request;
                if(!($request instanceof FhirRequest)) break;
                $identifier = $request->extractIdentifier();
                if($identifier) $this->removeCachedPatient($identifier);
                break;
            // delete access token if access is forbidden
            case '401':
                $accessToken = $fhirClientResponse->access_token;
                if($accessToken) {
                    $deleted = $this->deleteAccessToken($accessToken, $queryString);
                    if($deleted) Logging::logEvent($queryString, 'redcap_ehr_access_token', 'FHIR', $accessToken, '','Access token has been deleted', 'Permission denied');
                }
                break;
            default:
                # code...
                break;
        }

    }

    public function deleteAccessToken($access_token, &$query_string=null) {
        $ehr_id = $this->fhirSystem->getEhrId();
        $query_string = "DELETE FROM `redcap_ehr_access_tokens` WHERE `access_token`= ? AND ehr_id = ?";
        $result = db_query($query_string, [$access_token, $ehr_id]);
        return $result;
    }

    /**
     * Collects FHIR access tokens for specified users in a project. It retrieves the FHIR system based on the project ID and 
     * iterates through the usernames to fetch their tokens.
     * If the FHIR system is unavailable, the token for that user is set to false.
     *
     * @param int $project_id The ID of the project.
     * @param array $usernames Usernames for token collection.
     * @return array Associative array with usernames as keys and FHIR access tokens (or false) as values.
     */
    public static function getAccessTokensForUsersinProject($project_id, $usernames) {
        $fhirSystem = FhirSystem::fromProjectId($project_id);
        $fhirTokens = [];
        foreach ($usernames as $username) {
            if(!$fhirSystem) {
                $fhirTokens[$username] = false;
                continue;
            }
            $uiid = User::getUIIDByUsername($username);
            $tokenManager = new FhirTokenManager($fhirSystem, $uiid);
            $token = $tokenManager->getToken();
            $fhirTokens[$username] = $token;
        }
        return $fhirTokens;
    }

}

